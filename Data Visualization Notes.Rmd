---
title: "Data Visualization Notes"
author: "Steven Clarke"
date: "2019-02-19"
output: html_document
---

## Data Visualization Notes

This is a starter RMarkdown template to accompany *Data Visualization* (Princeton University Press, 2019). You can use it to take notes, write your code, and produce a good-looking, reproducible document that records the work you have done. At the very top of the file is a section of *metadata*, or information about what the file is and what it does. The metadata is delimited by three dashes at the start and another three at the end. You should change the title, author, and date to the values that suit you. Keep the `output` line as it is for now, however. Each line in the metadata has a structure. First the *key* ("title", "author", etc), then a colon, and then the *value* associated with the key.  

## This is an RMarkdown File

Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. A *code chunk* is a specially delimited section of the file. You can add one by moving the cursor to a blank line choosing Code > Insert Chunk from the RStudio menu. When you do, an empty chunk will appear:

```{r}


```

Code chunks are delimited by three backticks (found to the left of the 1 key on US and UK keyboards) at the start and end. The opening backticks also have a pair of braces and the letter `r`, to indicate what language the chunk is written in. You write your code inside the code chunks. Write your notes and other material around them, as here.

## Before you Begin

To install the tidyverse, make sure you have an Internet connection. Then *manually* run the code in the chunk below. If you knit the document if will be skipped. We do this because you only need to install these packages once, not every time you run this file. Either knit the chunk using the little green "play" arrow to the right of the chunk area, or copy and paste the text into the console window.

```{r install, eval = FALSE}

## This code will not be evaluated automatically.
## (Notice the eval = FALSE declaration in the options section of the
## code chunk)

my_packages <- c("tidyverse", "broom", "coefplot", "cowplot",
                 "gapminder", "GGally", "ggrepel", "ggridges", "gridExtra",
                 "here", "interplot", "margins", "maps", "mapproj",
                 "mapdata", "MASS", "quantreg", "rlang", "scales",
                 "survey", "srvyr", "viridis", "viridisLite", "devtools")

install.packages(my_packages, repos = "http://cran.rstudio.com")

```

We also need to download the *socviz* library from GitHub.

```{r eval = FALSE}
devtools::install_github("kjhealy/socviz")
```


## Set Up Your Project and Load Libraries

To begin we must load some libraries we will be using. If we do not load them, R will not be able to find the functions contained in these libraries. The tidyverse includes ggplot and other tools. We also load the socviz and gapminder libraries.

```{r setup, include=FALSE}

## By defult, show code for all chunks in the knitted document,
## as well as the output. To override for a particular chunk
## use echo = FALSE in its options.
knitr::opts_chunk$set(echo = TRUE)

## Set the default size of figures
knitr::opts_chunk$set(fig.width=8, fig.height=5)  

## Load the libraries we will be using
library(gapminder)
library(here)
library(socviz)
library(tidyverse)

```

Notice that here, the braces at the start of the code chunk have some additional options set in them. There is the language, `r`, as before. This is required. Then there is the word `setup`, which is a label for your code chunk. Labels are useful to briefly say what the chunk does. Label names must be unique (no two chunks in the same document can have the same label) and cannot contain spaces. Then, after the comma, an option is set: `include=FALSE`. This tells R to run this code but not to include the output in the final document.


When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r look}
gapminder
```

The remainder of this document contains the chapter headings for the book, and an empty code chunk in each section to get you started. Try knitting this document now by clicking the "Knit" button in the RStudio toolbar, or choosing File > Knit Document from the RStudio menu.

## Get Started

### Everything is an object

*c()* is a function, where c is short for "combine" or "concatenate". It takes a sequence of comma-separated elements in brackets and joins them into a vector where each element is still individually accessible.

```{r}
c(1, 2, 3, 1, 3, 5, 25)
```

We can assign this to a variable. Use Alt + - to produce the assignment symbol <-.

```{r}
my_numbers <- c(1, 2, 3, 1, 3, 5, 25)
your_numbers <- c(5, 31, 71, 1, 3, 21, 6)
```

Type in the variable name to see the assigned object.

```{r}
my_numbers
```

### You do things using functions

We can pass these numbers as an argument to functions.

#### Mean

*mean()* finds the mean of a set of numbers.

```{r}
mean(my_numbers)
```

#### Summary

You can assign the result of a function to a variable and output it.

*summary()* gives some summary statistics of the numbers.

```{r}
my_summary <- summary(my_numbers)
my_summary
```

### Functions come in packages

#### Table

*table()* provides a count of each element.

```{r}
table(my_numbers)
```

#### vector * scalar

If we multiply a vector by a number, each element in that vector gets multiplied by that number.

```{r}
my_numbers * 5
```

#### vector + scalar

If we add a number to a vector, that number is added to each element in turn.

```{r}
my_numbers + 1
```

#### vector + vector

If we add vectors of the same length (such as adding a vector to itself), each element in one vector is added to the corresponding element in the other vector.

```{r}
my_numbers + my_numbers
```

### If you're not sure what an object is, ask for its class

Every object has a class. Use the *class()* function to find the class of an object.

```{r}
class(my_numbers)
```

```{r}
class(my_summary)
```

```{r}
class(summary)
```

Actions can change a class. Adding a *character* to a *numeric* vector will turn the whole object to a *character* and the numbers will be enclosed in quotes.

```{r}
my_new_vector <- c(my_numbers, "Apple")
my_new_vector
```

### Data Tables and Tibbles

The most common type of data object in R is a *data frame*, which consists of a rectangular table consisting of rows (of observations) and columns (of variables).

Here is a small dataset from the *socviz* library:

```{r}
titanic
```

```{r}
class(titanic)
```

The $ operator allows you to pick out a named column of a data frame:

```{r}
titanic$percent
```

A *tibble* is an augmented data frame. We can convert a data frame to a tibble:

```{r}
titanic.tb <- as_tibble(titanic)
titanic.tb
```

### To see inside an object, ask for its structure

The *str()* function lets you see inside an object.

Objects can be simple...

```{r}
str(my_numbers)
```

...or objects can be more complicated, although they are usually organized collections of simpler objects.

```{r}
str(my_summary)
```

### Be patient with R, and with yourself

In *ggplot*, we will build up plots a piece at a time by adding expressions to one another. When doing this, make sure your + character goes at the end of the line, like this...

```{r eval = FALSE}
ggplot(data = mpg, aes(x = displ, y = hwy)) +
geom_point()
```

...not like this:

```{r eval = FALSE}
ggplot(data = mpg, aes(x = displ, y = hwy))
+ geom_point()
```

### Get data into R

Use the *read_csv()* function to read in comma-separated data.

Give the function an url and it will fetch the data. A message will be printed at the console, telling us that a class has been assigned to each column of the object it has created.

```{r}
url <- "https://cdn.rawgit.com/kjhealy/viz-organdata/master/organdonation.csv"

organs <-  read_csv(file = url)
```

### Make your first figure

Let us make a scatterplot of the *gapminder* data.

Let's take a look at the data first.

```{r}
gapminder
```

We will make a scatterplot of *lifeExp* (life expectancy) against *gdpPerCap* (GDP per capita).

```{r}
p <-  ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p  + geom_point()
```

## Make a Plot

At the end of *Chapter 2*, we plotted a graph using *ggplot*. The steps are always the same.

**Data**

First we tell *ggplot* what **data** we are using, using the *data* argument:

```{r eval = FALSE}
p <-  ggplot(data = gapminder)
```

**Aesthetic mappings**

Second, we tell *ggplot* which variables in the data should be **mapped** to visual elements in the plot, using the *mapping* argument.

It is passed the *aes()* function (for *aes*thetics).

```{r}
p <- ggplot(data = gapminder,

            mapping = aes(x = gdpPercap, y = lifeExp))
```

This says that the variable on the x-axis will be *gdpPercap* and the variable on the y-axis will be *lifeExp*.

But by this point, we don't yet have a graph...

```{r}
p
```

**Type of plot**

Add a *layer* specifying the type of plot you want by picking a *geom_* function.

We will use *geom_point()* to plot the x and y values as a scatterplot:

```{r}
p + geom_point()
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_scatterplot.pdf"))
```


### Build your plots layer by layer

Plots are built up by *adding layers* one at a time. It really is an *additive* process.

Let's try a different *geom_* function.

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_smooth()
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_smooth.pdf"))
```

This creates a smoothed line and adds a shaded ribbon showing the standard error of the line.

If we want to see the data points and the line together, we simply *add geom_point()* back in.

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point() + geom_smooth()
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_smooth_and_scatterplot.pdf"))
```

Notice in the console message that *geom_smooth()* is using *method = gam* (for generalized additive model).

We could instead use *method = lm* for a linear model.

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point() + geom_smooth(method = "lm")
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_smooth_lm.pdf"))
```

We haven't had to tell *geom_point()* or *geom_smooth()* where to get its data from. It *inherits* it from the *p* object.

Looking at our data, it is all bunched up against the left hand side. The scale would look better if it was transformed from a linear scale to a log scale.

Add the *scale_x_log10()* function to *p*:

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point() + geom_smooth(method = "gam") + scale_x_log10()
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_smooth_gam_log_scale.pdf"))
```

Notice the scientific notation used on the x-axis now we are using a log scale. Let's change to a sensible scale and use $ values (the unit of GDP per capita).

We will use the *scales* package's *dollar()* function. Rather than downloading the package, grab the function from it directly using the syntax *thepackage::thefunction*.

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point() +

    geom_smooth(method = "gam") +

    scale_x_log10(labels = scales::dollar)
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_dollar_scales.pdf"))
```

We can reformat the text under the tick marks using other *labels* functions.

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point() +

    geom_smooth(method = "gam") +

    scale_x_log10(labels = scales::comma)
```

### Mapping aesthetics vs setting them

An *aesthetic mapping* specifies that a variable will be expressed by one of the available visual elements, such as size, or colour, or shape.

We map variables to aesthetics like this:

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp, colour = continent))
```

This code does *not* give a direct instruction like "colour the points purple". Instead it says, "the property *colour* will represent the variable *continent*" or "*colour* will map *continent*".

Let's see what this looks like:

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp, colour = continent))

p + geom_point() + scale_x_log10(labels = scales::dollar)
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_colour_continent.pdf"))
```

Different colours are used to represent points with different *continent* properties.

If we want to turn all the points in the figure purple, we do *not* do it through the mapping function. Look at what happens when we try:

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp, colour = "purple"))

p + geom_point() + scale_x_log10(labels = scales::dollar)
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_map_colour_to_purple_in_aes.pdf"))
```

What is going on?

*mapping* wants to map the property *colour* to a variable and assumes it will get a variable. We give it *"purple"*. So every row of data is assigned a categorical variable, *purple*, which has the value of *"purple"*. We have created a new column of data, every item of which is *"purple"*.

*ggplot* maps this variable to the *colour* aesthetic, using its default first colour of red.

__The *aes()* function is for mapping only, not for setting a property value. If we want to set a property value, do it in the *geom_* function, outide the *mapping = aes(...)* step.__

Let's try this. Set *geom_point()*'s *colour* property to "purple:

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point(colour = "purple") + scale_x_log10(labels = scales::dollar)
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_set_colour_to_purple_in_geom.pdf"))
```

We can change the look by giving different arguments to the *geom_* functions. *alpha* sets the transparency (0 fully transparent, 1 fully opaque). *se* is a boolean, which turns the standard error ribbon on and off.

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point(alpha = 0.3) +

  geom_smooth(colour = "orange", se = FALSE, size = 8, method = "lm") +

  scale_x_log10(labels = scales::dollar)
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_styles.pdf"))
```

The *lab()* function controls the main *lab*els of the plot, as well as *title*, *subtitle* and *caption*.

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point(alpha = 0.3) +

  geom_smooth(method = "gam") +

  scale_x_log10(labels = scales::dollar) +

  labs(x = "GDP Per Capita", y = "Life Expectancy in Years",

       title = "Economic Growth and Life Expectancy",

       subtitle = "Data points are country-years",

       caption = "Source: Gapminder.")
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_labels.pdf"))
```

Let *colour* map the continent:

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp,

                                            colour = continent))

p + geom_point() + geom_smooth(method = "loess") + scale_x_log10()
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_colour_line_each_continent.pdf"))
```

We have five smoothing lines and standard error ribbons, one for each continent. This is a consequence of the way aesthetic mappings are inherited. *mapping = aes(...)* is set in the call to *ggplot* used to create the *p* object. *geom_point()* and *geom_smooth()* inherit from this.

We can set the shading of this standard error ribbon to match its dominant colour, using the *fill* property. Whereas *colour* affects the appearence of lines and points, *fill* is for the filled areas of bars, polygons and the interiors of the smoother's standard error ribbon.

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp,

                                            colour = continent, fill = continent))

p + geom_point() + geom_smooth(method = "loess") + scale_x_log10()
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_colour_line_and_fill_each_continent.pdf"))
```

### Aesthetics can be mapped per geom

Perhaps five separate smoothers is too many, and we just want one line. But we would still like to have the points colour-coded by continent.

By default, *geom*s inherit their mappings from the *ggplot()* function. We will map *x* and *y* in the *ggplot()* function as usual, which will be inherited by the *geom_* functions. We will then use *mapping = aes(colour = continent)* __only__ in *geom_point()*. This ensures that the points are colour-coded by continent, but *geom_smooth()* will only plot one line, as it does not map *continent* in any way.

```{r}
p <-  ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point(mapping = aes(colour = continent)) +

    geom_smooth(method = "loess") +

    scale_x_log10()
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_colour_points_each_continent_one_line.pdf"))
```

It is possible to map continuous variables to the *colour* aesthetic. We can map the log of each country-year's population, *pop*, to *colour*. (We can take the log of population right in the *aes()* statement using the *log()* function). When we do this, *ggplot* produces a gradient scale.

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point(mapping = aes(colour = log(pop))) + scale_x_log10()
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_gradient_scale_colour.pdf"))
```

The gradient scale of the colour is continuous but is marked at intervals in the legend. Depending on the circumstances, mapping quantities like population to a continuous colour gradient may be more or less effective than cutting the variable into categorial bins.

### Save your work

We can set the default size of plots within our _.Rmd_ document. This command tells _R_ to make 8 x 5 figures:

```{r}
knitr::opts_chunk$set(fig.width = 8, fig.height = 5)
```

We can change the size of particular plots by placing the same options to any particular chunk inside the curly brackets at the beginning.

A figure can be saved to a file using the *ggsave()* function. To save the most recently displayed figure, provide the name we want to save it under:

```{r}
ggsave(filename = "my_figure.png")
```

This will save the figure as a PNG file. If we want a PDF file instead, change the extension of the file:

```{r}
ggsave(filename = "my_figure.pdf")
```

We do not need to write *filename =* as long as the name of the file is the first argument in *ggsave()*. We can also pass plot objects to *ggsave()*. For example, we can put our most recent plot into an object called *p_out* and then tell *ggsave()* we want to save that object.

```{r}
p_out <-  p + geom_point() + geom_smooth(method = "loess") + scale_x_log10()

ggsave("other_figure.pdf", plot = p_out)
```

When saving your work, it is useful to have one or more subfolders where you save only figures. You should also take care to name your saved figures in a sensible way: *fig_1.pdf* or *my_figure.pdf* are not good names.

Create a folder named *figures*. Use the *here* library. *here()* outputs the file path. In this case *"C:/Users/Steven/Documents/Data Visualization - A Practical Introduction"*.

```{r}
here()
```

We can then us the *here()* function to make saving our work much easier. Assuming a folder named *figures* exists in the project folder, we can do this:

```{r}
ggsave(here("figures", "here_figure.pdf"), plot = p_out)
```

In general, you should save your work in several different formats and in different sizes. You can use *scale*, or set the *height* and *width* (and *units*) explicitly.

```{r}
ggsave(here("figures", "sized_figure.pdf"), plot = p_out,

       height = 8, width = 10, units = "in")
```

### Where to Go Next

__What happens when you put the *geom_smooth()* function before *geom_point()*...__

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_smooth() + geom_point()
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_smooth_before_point.pdf"))
```

__...instead of after it?__

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point() + geom_smooth()
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_point_before_smooth.pdf"))
```

If *geom_smooth()* comes before *geom_point()*, then the smoothed curve is shown beneath the points and is obscured by it.

If *geom_point()* comes before *geom_smooth()*, then the smoothed curve will be plotted over the points, obscuring them.

Plots are built layer by layer, with the later layers being placed on top.

***

__Change the mappings in the *aes()* function so that you plot life expectancy against population (*pop*) rather than per capita GDP.__

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = pop, y = lifeExp))

p + geom_point()
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_pop.pdf"))
```

Each point represents a country-year. The units of each point are taken from the dataframe, *lifeExp* is in years, *pop* is number of people.

The majority of the points are bunched on the left, the countries having relatively low populations.

There are then around 25 points further to the right, where *lifeExp* (starting from a low base) seems to increase with *pop*. This is the case of China, which starts with low life expectancy which then grows, along with its population.

***

__Try some alternative scale mappings. Besides *scale_x_log10()*, you can try *scale_x_sqrt()* and *scale_x_reverse()*. There are corresponding functions for y-axis transformations. Just write *y* instead of *x*.__

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point() +

  scale_x_sqrt() +

  labs(title = "scale_x_sqrt()")
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_scale_x_sqrt.pdf"))
```

The points are scaled as if each x value is square rooted. The lower values appear more stretched out, and larger values are compressed.

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point() +

  scale_y_sqrt() +

  labs(title = "scale_y_sqrt()")
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_scale_y_sqrt.pdf"))
```

The points are scaled as if each y value is square rooted. The lower values appear more stretched out, and larger values are compressed.

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point() +

  scale_x_reverse() +

  labs(title = "scale_x_reverse()")
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_scale_x_reverse.pdf"))
```

The x values are reversed, so points go right-to-left.

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point() +

  scale_y_reverse() +

  labs(title = "scale_y_reverse()")
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_scale_y_reverse.pdf"))
```

The y values are reversed, so points go up-to-down.

***

__What happens if you map *colour* to *year* instead of *continent*?__

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp, colour = year))

p + geom_point()
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_colour_year.pdf"))
```

The *year* variable is a number. Higher numbers (later years) are given a lighter colour than lower numbers (earlier years), as seen in the colour scale in the legend. Countries generally seem to have life expectancy and GDP per capita increasing as the years progress.

***

__Instead of mapping *colour = year*, what happens if you try *colour = factor(year)*?__

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp, colour = factor(year)))

p + geom_point()
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_colour_factor(year).pdf"))
```

*factor()* makes the *year* value categorical. Each year is a discrete category and gets its own colour.

***

__What might be a better visualization of our data, that does not ignore its temporal and country-level structure?__

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_point(mapping = aes(colour = country, alpha = year)) +

  geom_smooth(method = "lm") +

  scale_x_log10(labels = scales::dollar) +

  labs(x = "GDP Per Capita", y = "Life Expectancy in Years",

       title = "Economic Growth and Life Expectancy",

       subtitle = "Data points are country-years",

       caption = "Source: Gapminder.") +

  theme(legend.position = "none")
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_better_visualization.pdf"))
```

Each *country* is mapped to a *colour* and the *year* is mapped to *alpha*, so later years are more opaque. I have removed the legend, due to there being so many countries, but you would need to see which colour represents each country.

## Show the Right Numbers

### Grouped Data and the "Grouped" Aesthetic

Beginning with the *gapminder* dataset, imagine we wanted to see how GDP per capita changes over time. Let's plot *year* and *gdpPercap* for each country-year:

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = year, y = gdpPercap))

p + geom_point()
```

```{r include = FALSE}
ggsave(here("figures", "year_vs_gdp.pdf"))
```

Imagine we wanted to plot the trajectory of GDP per capita for each country by joining them with lines:

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = year, y = gdpPercap))

p + geom_line()
```

```{r include = FALSE}
ggsave(here("figures", "year_vs_gdp_lines_wrong.pdf"))
```

This is not what we wanted. Points for each year have been joined, whereas we wanted points for each country to be joined.

Use the *group* aesthetic to tell *ggplot* explicitly about the country-level structure:

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = year, y = gdpPercap))

p + geom_line(aes(group = country))
```

```{r include = FALSE}
ggsave(here("figures", "year_vs_gdp_lines_group_country.pdf"))
```

The lines now show the trajectory of GDP per capita of a country over time.

__We have used the *group* aesthetic because the grouping we wanted (*country*) was not built into the variables being mapped (*year* and *gdpPercap*). There is no information in the *year* variable itself to let *ggplot* know that it is grouped by *country*.__

### Facet to Make Small Multiples

The previous plot is very messy. One option is to *facet* the data by some third variable, making a "small multiple" plot.

A separate panel is drawn for each value of the faceting variable. Facets are not a *geom*, but a way of organising a series of *geom*s. In this case, we will use *facet_wrap()* to split the plot by *continent*. Pass *continent* as an argument with a ~.

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = year, y = gdpPercap))

p + geom_line(aes(group = country)) +

  facet_wrap(~continent)
```

```{r include = FALSE}
ggsave(here("figures", "year_vs_gdp_lines_group_country_facet_continent.pdf"))
```

We can add a smoother and some cosmetic enhancements.

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = year, y = gdpPercap))

p + geom_line(colour = "gray70", aes(group = country)) +

  geom_smooth(size = 1.1, method = "loess", se = FALSE) +

  scale_y_log10(labels=scales::dollar) +

  facet_wrap(~continent, ncol = 5) +

  labs(x = "Year",

       y = "GDP per capita",

       title = "GDP per capita on Five Continents")
```

```{r include = FALSE}
ggsave(here("figures", "year_vs_gdp_country_by_continent.pdf"))
```

Data can be cross-classified by two categorical variables by using *facet_grid()*. We will use the *gss_sm* dataset, which is a small subset of the questions from the 2016 General Social Survey. Unlike the *gapminder* dataset, it contains many categorical variables.

We wish to make a smoothed scatterplot of the relationship between the age of the respondent (*age*) and the number of children they have (*childs*). We will facet this relationship by *sex* and *race*, using *facet_grid(sex ~ race)*:

```{r}
p <-  ggplot(data = gss_sm,

             mapping = aes(x = age, y = childs))

p + geom_point(alpha = 0.2) +

  geom_smooth() +

  facet_grid(sex ~ race)
```

```{r include = FALSE}
ggsave(here("figures", "age_vs_children_facet_grid().pdf"))
```

Further categorical variables can be added, such as *facet_grid(sex ~ race + degree)*, which will have a row for each *sex* variable and a column for each combination of *race* and *degree*.

### Geoms Can Transform Data

Whereas *geom_point()* just plots a point with given x and y coordinates, other *geom*s transform data before they are plotted (think of the smoother created by *geom_smooth()*).

Every *geom_* function has an associated *stat_* function and vice versa.

Sometimes the calculations done by the *stat_* functions are not immediately obvious. Consider *geom_bar()*:

```{r}
p <-  ggplot(data = gss_sm, mapping = aes(x = bigregion))

p + geom_bar()
```

```{r include = FALSE}
ggsave(here("figures", "bigregion_barchart.pdf"))
```

The bar height gives the count of observations from each region of the USA. There is a y-axis variable, called *count*, that is not in the data but has been calculated for us. Behind the scenes, *geom_bar()* calls its default *stat_* function, *stat_count()*. The function computes two new variables, *count* and *prop* (short for proportion). If we want to use *prop* in our bar chart, it must be used as a mapping. The relevant argument is *..prop..* (we need it to begin and end with two periods so that it won't be confused if there is already a *prop* variable in our data. __Use *mapping = aes(variable =* ..statistic..*)*__

```{r}
p <-  ggplot(data = gss_sm, mapping = aes(x = bigregion))

p + geom_bar(mapping = aes(y = ..prop..))
```

```{r include = FALSE}
ggsave(here("figures", "bigregion_barchart_prop_wrong.pdf"))
```

This is not what we want. The data is being grouped by the x-categories, whereas we want the whole data to be grouped, so each bar represents the proportion of the whole data. We do this using *group = 1* inside the aes() call (1 being a "dummy group" representing the whole dataset).

```{r}
p <-  ggplot(data = gss_sm, mapping = aes(x = bigregion))

p + geom_bar(mapping = aes(y = ..prop.., group = 1))
```

```{r include = FALSE}
ggsave(here("figures", "bigregion_barchart_prop_group_1.pdf"))
```

The *gss_sm* data contains a *religion* variable. Let's graph this as a bar chart, with a colour for each religion:

```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = religion, fill = religion))

p + geom_bar() + guides(fill = FALSE)
```

```{r include = FALSE}
ggsave(here("figures", "religion_barchart.pdf"))
```

Both *x* and *fill* are mapped to *religion*. Because we do not need a legend showing which colour represents each religion (we can read that from the x-axis), we turn off the legend using *guides(fill = FALSE)*.

### Frequency Plots the Slightly Awkward Way

A more appropriate use of the *fill* aesthetic with *geom_bar()* is to cross-classify two categorical variables. For example, to examine the distribution of religious preferences within different regions of the United States. (__Note:__ This is not the most straightforward way of producing these bar charts. We will see a better way in the next chapter, where we calculate a table first).

Let's look at the breakdown of religion by region; that is, we want the *religion* variable broken down proportionally within *bigregion*. Map *fill* to *religion*:

```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = bigregion, fill = religion))

p + geom_bar()
```

```{r include = FALSE}
ggsave(here("figures", "religion_by_bigregion_barchart.pdf"))
```

This is a stacked bar chart, where the counts of each religion are stacked within each bar. A problem with this is that each religion is unaligned and so it is hard to compare the heights.

An alternative is to set the *position* argument to "fill" in the *geom_* function:

```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = bigregion, fill = religion))

p + geom_bar(position = "fill")
```

```{r include = FALSE}
ggsave(here("figures", "religion_by_bigregion_using_position_fill_barchart.pdf"))
```

This makes it easier to compare the proportion of each religion in a region, but we lose the relative sizes of the regions.

We could also set *position = "dodge"* to place the religions side by side in each region...

```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = bigregion, fill = religion))

p + geom_bar(position = "dodge")
```

```{r include = FALSE}
ggsave(here("figures", "religion_by_bigregion_using_position_dodge_barchart.pdf"))
```

...but this shows counts, not proportions. We have already seen that using *y = ..prop..* can be used to use proportions...

```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = bigregion, fill = religion))

p + geom_bar(position = "dodge", mapping = aes(y = ..prop..))
```

```{r include = FALSE}
ggsave(here("figures", "religion_by_bigregion_using_position_dodge_y_prop_barchart.pdf"))
```

...but this is not useful. The problem is we are seeing the proportion of Protestants that are Protestant (and Catholics are Catholic etc.) in each region, which is 100% in each case. Previously we fixed this using the *group* argument. If we set *group = religion*...

```{r}
p <-  ggplot(data = gss_sm, mapping = aes(x = bigregion, fill = religion))

p + geom_bar(position = "dodge", mapping = aes(y = ..prop.., group = religion))
```

```{r include = FALSE}
ggsave(here("figures", "religion_by_bigregion_using_position_dodge_y_prop_group_religion_barchart.pdf"))
```

...then we see what proportion of Protestants live in each region (and Catholics etc). So we see that nearly half of all Protestants live in the South. The bars for each religion sum to one across the regions, but the bars do not sum to one in each region.

The easiest thing to do is to stop trying to force *geom_point()* to do all the work in a single step. Instead, we ask *ggplot* to give us a proportional bar chart of religious affiliation, and then facet that by region.

```{r}
p <- ggplot(data = gss_sm, mapping = aes(x = religion))

p + geom_bar(mapping = aes(y = ..prop.., group = bigregion)) + facet_wrap(~bigregion)
```

```{r include = FALSE}
ggsave(here("figures", "religion_by_bigregion_using_facet_wrap.pdf"))
```

Note: in this case we group by *bigregion*, not *religion*. Otherwise we will just find that 100% of Protestants in a region are Protestant.

### Histograms and Density Plots

A histogram is a way of summarizing a continuous variable by chopping it up into segments or "bins" and counting how many observations are found within each bin. We have to decide how finely to bin the data.

The *midwest* dataset contains information on counties in several midwestern states of the United States. Counties vary in size, so we can make a histogram showing the distribution of their geographical areas (measured in square miles).

We need to divide the observations in to bins. *geom_histogram()* will choose a bin size for us based on a rule of thumb. The histogram displays a count of observations in each bin.

```{r}
p <- ggplot(data = midwest, mapping = aes(x = area))

p + geom_histogram()
```

```{r include = FALSE}
ggsave(here("figures", "midwest_county_area_histogram_default_bins.pdf"))
```

We can set the number of bins using *bins*, or the width of each bin using *binwidth*:

```{r}
p <- ggplot(data = midwest, mapping = aes(x = area))

p + geom_histogram(bins = 10)
```

```{r include = FALSE}
ggsave(here("figures", "midwest_county_area_histogram_10_bins.pdf"))
```

As with bar charts, a newly created *count* variable is created and displayed.

We can display multiple histograms in one plot. Let's *subset* our data so we only look at counties in two states: Ohio "OH" and Wisconsin "WI", giving them different fills.

```{r}
oh_wi <- c("OH", "WI")

p <- ggplot(data = subset(midwest, subset = state %in% oh_wi), mapping = aes(x = percollege, fill = state))

p + geom_histogram(alpha = 0.4, bins = 20)
```

```{r include = FALSE}
ggsave(here("figures", "midwest_county_percent_college_histogram_OH_and_WI.pdf"))
```

An alternative to a histogram is to calculate a kernel density estimate of the underlying distribution. The *geom_density()* function will do this:

```{r}
p <-  ggplot(data = midwest, mapping = aes(x = area))

p + geom_density()
```

```{r include = FALSE}
ggsave(here("figures", "midwest_county_area_density.pdf"))
```

A similar plot can be achieved using *geom_line(stat = "density")*, which removes the lines at the sides and bottom of the area (and doesn't allow a fill):

```{r}
p <-  ggplot(data = midwest, mapping = aes(x = area))

p + geom_line(stat = "density")
```

```{r include = FALSE}
ggsave(here("figures", "midwest_county_area_line_density.pdf"))
```

We can use *colour* and *fill* for *geom_density()* too. We could map each state to a different colour and fill, allowing us to see them in one plot.

```{r}
p <- ggplot(data = midwest, mapping = aes(x = area, colour = state, fill = state))

p + geom_density(alpha = 0.3)
```

```{r include = FALSE}
ggsave(here("figures", "midwest_county_area_colour_and_fill_for_each_state.pdf"))
```

When using *geom_bar()*, we saw we could use the *..prop..* statistic for a proportional measure instead of the *..count..* statistic. We can do something similar with *geom_histogram()* and *geom_density()* using their *stat_* functions.

From *geom_density()*, the *stat_density()* function can return its default *..density..* statistic, or *..scaled..*, which will give a proportional density estimate.

```{r}
p <- ggplot(data = subset(midwest, subset = state %in% oh_wi),

            mapping = aes(x = area, fill = state, colour = state))

p + geom_density(alpha = 0.3, mapping = aes(y = ..scaled..))
```

```{r include = FALSE}
ggsave(here("figures", "midwest_county_density_scaled.pdf"))
```

It can also return a statistic called *..count..*, which is the density times the number of points. This can be used in stacked density plots.

```{r}
p <- ggplot(data = subset(midwest, subset = state %in% oh_wi),

            mapping = aes(x = area, fill = state, colour = state))

p + geom_density(alpha = 0.3, mapping = aes(y = ..count..))
```

```{r include = FALSE}
ggsave(here("figures", "midwest_county_density_count.pdf"))
```

### Avoid Transformations When Necessary

Sometimes data will already have counts or proportions in them...

```{r}
titanic
```

...so we do not need a *stat_* function to calculate these things for us. Use *stat = "identity"* in the *geom_* function. (We'll also move the legend to the top of the plot):

```{r}
p <- ggplot(data = titanic, mapping = aes(x = fate, y = percent, fill = sex))

p + geom_bar(position = "dodge",
             
             stat = "identity") + theme(legend.position = "top")
```

```{r include = FALSE}
ggsave(here("figures", "titanic_stat_identity.pdf"))
```

*geom_col()* has the same effect as using *geom_bar(stat = "identity")*.

We can also use *position = "identity"* to plot the values as given. This lets us plot a flow of positive and negative values in a bar chart. This is useful when looking at changes relative to some threshold level or baseline. The *oecd_sum* table in *socviz* contains information on average life expectancy at birth within the USA and other OECD countries.

```{r}
oecd_sum
```

The *other* column is the average life expectancy in a given year for countries *excluding* the United States. The *usa* column is the U.S. life expectancy. *diff* is the difference between the two values and *hi_lo* indicates whether the U.S. value is higher or lower than the OECD average.

We will plot the difference over time and use the *hi_lo* variable to colour the columns in the chart.

```{r}
p <- ggplot(data = oecd_sum, mapping = aes(x = year, y = diff, fill = hi_lo))

p + geom_col() + guides(fill = FALSE) +

  labs(x = NULL, y = "Difference in Years",
       
       title = "The US Life Expectancy Gap",
       
       subtitle = "Difference between US and OECD average life expectancies, 1960-2015",
       
       caption = "Data: OECD. After a chart by Christopher Ingraham, Washington Post, December 27th 2017.")
```

```{r include = FALSE}
ggsave(here("figures", "difference_between_US_and_other_OECD_countries_average_life_expectancies.pdf"))
```

### Where to Go Next

__Revisit the *gapminder* plots at the beginning of the chapter and experiment with different ways to facet the data.__

__Try plotting population and per capita GDP while faceting on year__

```{r}
p <-  ggplot(data = gapminder, mapping = aes(x = pop, y = gdpPercap))

p + geom_point(colour = "gray70") + geom_smooth(se = FALSE) + facet_wrap(~year)
```

```{r include = FALSE}
ggsave(here("figures", "gdp_vs_pop_facet_year.pdf"))
```

__Try plotting population and per capita GDP while faceting on country__

```{r fig.width=25, fig.height=25}
p <-  ggplot(data = gapminder, mapping = aes(x = pop, y = gdpPercap))

p + geom_point(colour = "gray70") + geom_smooth(se = FALSE) + facet_wrap(~country)
```

***

__Investigate the difference between a formula written as *facet_grid(sex ~ race)* and one written as *facet_grid(~ sex + race)*.__

If we use *facet_grid(sex ~ race)*...

```{r}
p <-  ggplot(data = gss_sm, mapping = aes(x = age, y = childs))

p + geom_point(alpha = 0.2) + geom_smooth() + facet_grid(sex ~ race)
```

```{r include = FALSE}
ggsave(here("figures", "facet_grid(sex_~_race).pdf"))
```

...the facets break out the data into sex (rows) and race (columns).

If we use *facet_grid(~ sex + race)*...

```{r}
p <-  ggplot(data = gss_sm, mapping = aes(x = age, y = childs))

p + geom_point(alpha = 0.2) + geom_smooth() + facet_grid(~ sex + race)
```

```{r include = FALSE}
ggsave(here("figures", "facet_grid(~_sex_+_race).pdf"))
```

...the facets break out the data for each combination of sex and race.

***

__Experiment to see what happens when you use *facet_wrap()* with more complex formulas like *facet_wrap(~ sex + race)* instead of *facet_grid()*.__

```{r}
p <-  ggplot(data = gss_sm, mapping = aes(x = age, y = childs))

p + geom_point(alpha = 0.2) + geom_smooth() + facet_wrap(~ sex + race)
```

```{r include = FALSE}
ggsave(here("figures", "facet_wrap(~_sex_+_race).pdf"))
```

*facet_wrap()* breaks out the data for each combination of sex and race (as does *facet_grid()*) but lays out the results in a wrapped 1D table rather than a fully cross-classified grid.

***

__Frequency polygons are closely related to histograms. Instead of displaying the count of observations using bars, they display it with a series of connected lines. Try the various *geom_histogram()* calls in this chapter using *geom_freqpoly()* instead.__

__Default *geom_freqpoly()*__

```{r}
p <-  ggplot(data = midwest, mapping = aes(x = area))

p + geom_freqpoly()
```

```{r include = FALSE}
ggsave(here("figures", "midwest_count_area_freqpoly_default_bins.pdf"))
```

__Define the Number of Bins__

We can still define bins and binwidth...

```{r}
p <-  ggplot(data = midwest, mapping = aes(x = area))

p + geom_freqpoly(bins = 10)
```

```{r include = FALSE}
ggsave(here("figures", "midwest_count_area_freqpoly_10_bins.pdf"))
```

__Subset the Data__

```{r}
oh_wi <- c("OH", "WI")

p <-  ggplot(data = midwest, subset = subset(midwest, subset = state %in% oh_wi), mapping = aes(x = percollege))

p + geom_freqpoly(bins = 20)
```

```{r include = FALSE}
ggsave(here("figures", "midwest_county_percent_college_freqpoly_OH_and_WI.pdf"))
```

***

__A histogram bins observations for one variable and shows a bar with the count in each bin. We can do this for two variables at once, too. The *geom_bin2d()* function takes two mappings, *x* and *y*. It divides the plot into a grid and colours the bins by the count of observations in them. Try plotting it on the *gapminder* data to plot life expectancy versus per capita GDP.__

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

p + geom_bin2d()
```

```{r include = FALSE}
ggsave(here("figures", "lifeexp_vs_gdp_geom_bin2d().pdf"))
```

The size of the bins needs to be set in 2 dimensions now, e.g. *bins = c(20,50)*.

***

__Density estimates can also be drawn in two dimensions. The *geom_density_2d()* function draws contour lines estimating the joint distribution of two variables.__

__Try it with the *midwest* data, plotting percent below the poverty line (*percbelowpoverty*) against percent college-educated (*percollege*).__

__Try it with a *geom_point()* layer...__

```{r}
p <-ggplot(data = midwest, mapping = aes(x = percollege, y = percbelowpoverty))

p + geom_density_2d() + geom_point()
```

```{r include = FALSE}
ggsave(here("figures", "percbelowpoverty_vs_percollege_geom_density_2d()_and_geom_point().pdf"))
```

__...and without a *geom_point()* layer__

```{r}
p <-ggplot(data = midwest, mapping = aes(x = percollege, y = percbelowpoverty))

p + geom_density_2d()
```

```{r include = FALSE}
ggsave(here("figures", "percbelowpoverty_vs_percollege_geom_density_2d().pdf"))
```

## Graph Tables, Make Labels, Add Notes

```{r}

```

## Work with Models

```{r}

```

## Draw Maps

```{r}

```


## Refine your Plots

```{r}

```
